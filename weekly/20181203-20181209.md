# Review
[How unreliable is UDP?](https://www.openmymind.net/How-Unreliable-Is-UDP/)

本文讲述了 UDP 到底有多不靠谱，作者在 5 台 VPS 上进行了这个实验，实验时长 7 小时，每 9 - 11 秒会发送 5-10 个 UDP 包给其他的一台服务器（随机选择），包的大小在 16 - 1016 字节之间。

VPS 有两台在 New Jersey，另外的三台分别在 LA, Amsterdam and Tokyo

作者实验得到的丢包率并没有想像中的大 [pic](./udp_reliable.jpg), 最低的 98.55%，有不少 100% 的。并且丢失率和物理距离无直接关系，和包大小无直接关系。

但是作者实验发现，包的顺序却成了大问题，如果我们把后到的包都丢弃掉的话，那么最终剩下的包的总比例最低的只有 37.53%，如果我们把收到的包 5 个 package 都排序，然后再丢掉后到的包，剩下的包的总比例最低的有 59.9%。

本文作者没有记录丢失的包是不是在同一时段发生（可能物理硬件导致的之类）。

最终我们知道 UDP 的包丢失率并没有想像的高，但是包的顺序却是一个大问题。如果我们对顺序没有那么大的要求，那么选择 UDP 或许是个不错的选择。

# LeetCode
[最小路径和](https://leetcode.com/problems/minimum-falling-path-sum/) 
一个很简单却很经典的动态规划问题，这道题可以先用搜索解，然后搜索的过程中尝试记录那些重复访问的状态，然后再考虑正向推导。

转移方程: f[i][j] = A[i][j] + min(f[i-1][j-1], f[i-1][j], f[i-1][j]) 注意边界条件，最后遍历最后一行即可。

这题最小也就 -100*100，所以越界啥的也不需要考虑

# Tips
Java microbench 使用 JMH 框架，这样很方便，而且出来的结果直观，不过 JMH 的官方文档不是很全，只能看 demo 和邮件列表，这个对于大部分人可能不是那么适应，那么就在往上找类似教程的文章吧。

# 分享
这周在做一个小的重构，主要目的是解决之前的性能问题，但是重构的时间比较紧张，不可避免的就会有加班。由于性能是硬性指标，但是时间又不够的情况下，怎么办呢？我们就必须尽最大可能复用现有的代码，用最少的时间在现有的基础上用上新的架构，这样首先能够达到目标，后续继续进行重构，而且我们可以尽快的验证前期设计的目标是否能够达到。类似于新架构的一个原型，虽然理论上是会很好，最终我们还是需要以实际结果为准
